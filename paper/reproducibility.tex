\documentclass{article}

\begin{document}
\chapter{Reproducibility}

This is something I want to put a big stake in the ground on: nobody can
reproduce any of the VLSI results that other people have produced for any ISCA
papers, at least as far as I know.  This is a big problem because it means
people can lie: I know we're doing this, and it was a major factor in me
deciding to leave grad school.

This section is going to be more of a tutorial on using PLSI than a big dig at
how people are doing things the wrong way, since I don't want to get into too
much trobule.  It'll essentially be a LaTeX version of the PLSI README, focused
on walking people through exactly how to reproduce the results discussed in
this paper.  I'm going to open source my thesis Makefiles that wrap PLSI to
produce all the results for this paper in the hopes it'll teach other people
how to get proper results for their papers.

The results will be focused on ``I have access to the Synopsys tools and EDK
(but no commercial technologies) and I have an architectual idea (I'll propose
a bad idea) but I don't know how to produce energy results.''  I think this is
a pretty common problem among ISCA-types.  The plan is to walk people through
how to setup PLSI, how to write software to test and benchmark their idea,
where to stick it in Rocket Chip, how to run PLSI with the new suff, and then
how to compare it to the baseline (which presumably is without their widget).

This section is the most likely to get cut down, as it's not essential.

\section{A Bad Idea}

Here I'll propose my idea.  It'll be a bad one: if I had a good one I'd write a
thesis about that.  I'm not sure what the idea is going to be, I'm thinking
something DSP-like, since it's easy to come up with bad ideas there and to
implement them.

I'm thinking some sort of auto-incrementing loop thing would be a good example:
it'd be something simple to demonstrate compiler support for, would probably
add an extra port to the register file so the VLSI results are meaningful, and
would have a small performance gain on many codes.  Thus it would setup a good
tradeoff space: you'd get fewer cycles per benchmark, but presumably either
higher cycle time or area.  I'm thinking of calling it ``\texttt{Xbogo}'', since
it'd speed up Linux's BogoMIPS metric significantly.  It'll blow thorugh a
bunch of opcode space, but it's a bad idea so who cares.

\section{Configuring PLSI}

What you need to setup PLSI and run it, along with an example from this thesis
that shows exactly the dozen or so variables that need to be set in order to
reproduce these numbers.

\section{Producing Tests and Benchmarks}

How to write software for your widget and how to run that software in many
levels of simulation.  In this case it'd involve adding some RISC-V tests as
the test cases, and then adding ``\texttt{-march=...Xbogo}'' support to GCC.
That should be pretty straight-forward, as lots of people have
auto-incrementing loads.

\subsection{The Difference Between a Test and a Benchmark}

You need both: the tests are to check edge cases to make sure your stuff works,
and the benchmarks are to test common cases to ensure your widget improves
performance.

\section{Extending Rocket Chip}

How to implement your widget in Rocket Chip, which includes both BOOM and
Rocket.

\section{Producing VLSI Results}

How to run PLSI to produce the results you need, including with and without
your widget.

\section{Interpreting VLSI Results}

A bit on how to ensure your VLSI results are valid before interpreting them.
The scripts do pretty much all of this, but it will be a discussion of why you
couldn't just go and build a chip with the produced GDS (essentially it's not
DRC+LVS clean, and doesn't have IOs).

\end{document}
